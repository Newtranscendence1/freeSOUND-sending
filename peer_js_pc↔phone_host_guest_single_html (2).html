<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PC↔Phone PeerJS (Host/Guest) – Single HTML</title>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:linear-gradient(160deg, #0b1222, #0e1017 65%, #0b1222); color:var(--text); }
    .wrap { max-width: 920px; margin: 32px auto; padding: 0 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:16px; }
    h1 { font-size: 22px; letter-spacing: .2px; font-weight:700; }
    .card { background: rgba(17,24,39,.75); border:1px solid rgba(148,163,184,.15); border-radius:18px; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); backdrop-filter: blur(6px); }
    .grid { display:grid; grid-template-columns: 1.2fr 1fr; gap:16px; }
    @media (max-width: 860px){ .grid{ grid-template-columns: 1fr; } }
    label { font-size: 12px; color: var(--muted); display:block; margin-bottom:6px; }
    input, select, button, textarea { font: inherit; }
    input[type=text], select { width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(148,163,184,.18); background:#0b1020; color:var(--text); outline:none; }
    input[readonly]{ color:#b1b7c2; }
    .row { display:flex; gap:10px; align-items: end; flex-wrap: wrap; }
    .btn { padding:10px 14px; border-radius:12px; border:1px solid rgba(148,163,184,.25); background:#0b1020; color:var(--text); cursor:pointer; transition: .15s transform ease; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background:linear-gradient(135deg, #1f97ff 0, #22d3ee 100%); border:none; color:#00111a; font-weight:700; }
    .btn.warn { background:#1f2937; border:1px solid #ef4444; color:#fecaca; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#0b1020; border:1px solid rgba(148,163,184,.25); color:#cbd5e1; font-size:12px; }
    .muted { color: var(--muted); font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .log { white-space: pre-wrap; font-size:12px; line-height:1.45; background:#0b1020; border:1px solid rgba(148,163,184,.2); border-radius:12px; padding:10px; height:220px; overflow:auto; }
    .hidden { display:none !important; }
    .ok { color:#86efac; }
    .bad { color:#fca5a5; }
    footer { margin-top: 16px; font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>PeerJS PC↔Phone (Host/Guest) – 내부 오디오 전송</h1>
      <span class="pill">WebRTC · PeerJS 1.5</span>
    </header>

    <div class="grid">
      <section class="card">
        <div class="row" style="gap:12px; align-items:flex-start;">
          <div style="flex:1 1 240px;">
            <label for="role">역할 선택</label>
            <select id="role">
              <option value="host">Host (PC)</option>
              <option value="guest">Guest (Phone)</option>
            </select>
            <div class="muted" style="margin-top:6px;">Host는 PC의 <b>시스템 오디오</b>를 공유합니다. Guest는 듣기 전용입니다.</div>
          </div>
          <div style="flex:1 1 260px;">
            <label>내 Peer ID</label>
            <div class="row">
              <input id="myId" class="mono" type="text" readonly>
              <button id="copyId" class="btn">복사</button>
              <button id="refreshPeer" class="btn">재발급</button>
              <button id="reconnectPeer" class="btn">재연결</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:14px; gap:12px; align-items:flex-end;">
          <div style="flex:1 1 320px;">
            <label for="remoteId">상대 Peer ID</label>
            <input id="remoteId" class="mono" type="text" placeholder="상대(연결할) Peer ID 입력" />
          </div>
          <div class="row" style="gap:10px;">
            <button id="callBtn" class="btn primary">연결 (Call)</button>
            <button id="hangupBtn" class="btn warn">끊기 (Hang up)</button>
          </div>
        </div>

        <div id="hostControls" style="margin-top:16px;">
          <label>Host(PC) – 내부 오디오 캡처</label>
          <div class="row">
            <button id="startShare" class="btn">오디오 공유 시작</button>
            <button id="stopShare" class="btn warn">오디오 공유 중지</button>
            <span id="captureState" class="pill">미시작</span>
          </div>
          <div class="muted" style="margin-top:6px;">
            브라우저 정책상 <b>내부 오디오</b>는 <code>getDisplayMedia({ audio:true })</code>로만 캡처가 가능하며, 일부 브라우저에선 
            <span class="mono">video:true</span>가 필요할 수 있습니다. (이 경우 화면 썸네일 공유 UI가 표시됩니다)
          </div>
        </div>

        <div id="guestControls" class="hidden" style="margin-top:16px;">
          <label>Guest(Phone) – 재생 제어</label>
          <div class="row">
            <button id="enableSound" class="btn">사운드 활성화</button>
            <span class="muted">모바일(iOS Safari 등)에선 사용자 제스처 후 재생 가능</span>
          </div>
        </div>
      </section>

      <section class="card">
        <label>원격 오디오</label>
        <audio id="remoteAudio" controls autoplay playsinline></audio>
        <div class="muted" style="margin-top:6px;">연결되면 여기서 Host의 시스템 오디오가 재생됩니다.</div>
        <div style="margin-top:16px;">
          <label>상태 & 로그</label>
          <div id="log" class="log"></div>
        </div>
      </section>
    </div>

    <footer>
      팁: 먼저 Host(PC)에서 <b>오디오 공유 시작</b> 버튼을 누르고, <b>연결(Call)</b>로 상대 ID에 전화를 거는 흐름이 가장 안정적입니다. 
      Host가 수신(Call 수신) 방식으로도 동작하지만, <code>getDisplayMedia</code>는 사용자 클릭이 필요해 자동 요청이 제한될 수 있습니다.
    </footer>
  </div>

  <script>
    // ---------- DOM helpers ----------
    const $ = (sel) => document.querySelector(sel);
    const logEl = $('#log');
    function log(msg, cls) {
      const time = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      if (cls) line.className = cls;
      line.textContent = `[${time}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    // ---------- PeerJS setup ----------
    let peer = null;
    let myId = null;
    let activeCall = null;           // MediaConnection
    let systemStream = null;         // Host가 보낼 스트림
    let activeConn = null;           // DataConnection (게스트가 콜백 요청용)
    let pendingPeerToCall = null;    // 콜백 대기중인 상대 ID

    const peerConfig = {
      debug: 2,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
        ]
      }
    };

    async function createPeer() {
      if (peer) { try { peer.destroy(); } catch(e){} }
      log('피어 초기화 중…');
      peer = new Peer(undefined, peerConfig);

      peer.on('open', id => {
        myId = id;
        $('#myId').value = id;
        log(`Peer open: ${id}`, 'ok');
      });

      peer.on('error', err => {
        const msg = (err && err.type) ? `${err.type}: ${err}` : String(err);
        log(`Peer error: ${msg}`, 'bad');
      });

      peer.on('disconnected', () => {
        log('Peer disconnected (서버 연결 끊김). 자동 재연결 시도…', 'bad');
        try { peer.reconnect(); } catch (e) { log('reconnect() 실패: ' + e, 'bad'); }
      });

      peer.on('close', () => {
        log('Peer closed (완전 종료됨). 새 ID로 재생성 필요', 'bad');
      });

      // 수신 콜 처리: Host는 systemStream이 있으면 보내며, Guest는 듣기만
      peer.on('call', call => {
        log(`수신 호출 from ${call.peer}`);
        try { activeCall?.close(); } catch(e){}
        activeCall = call;

        const role = $('#role').value;
        try {
          if (role === 'host' && systemStream) {
            call.answer(systemStream);
            log('수신 콜에 systemStream으로 응답', 'ok');
          } else {
            // Guest 또는 Host이지만 아직 캡처 전: 송신 없이 수신만
            call.answer();
            log('수신 콜에 송신 없이 응답(수신 전용)', 'ok');
          }
        } catch (e) {
          log('answer() 실패: ' + e, 'bad');
        }

        wireCallEvents(call);
      });

      // 데이터 연결(게스트가 콜백 요청 시 사용)
      peer.on('connection', (conn) => {
        log(`데이터 연결 수신 from ${conn.peer}`);
        activeConn = conn;
        conn.on('open', () => log('데이터 채널 open', 'ok'));
        conn.on('data', (data) => {
          log('수신 데이터: ' + JSON.stringify(data));
          if (data && data.type === 'ring') {
            pendingPeerToCall = conn.peer;
            tryCallBackIfReady();
          }
        });
        conn.on('close', () => log('데이터 연결 종료'));
        conn.on('error', (e) => log('데이터 연결 에러: ' + e, 'bad'));
      });
    }

    function tryCallBackIfReady(){
      const role = $('#role').value;
      if (role === 'host' && pendingPeerToCall) {
        if (systemStream) {
          try { activeCall?.close(); } catch(e){}
          try {
            const call = peer?.open ? peer.call(pendingPeerToCall, systemStream) : null;
            if (!call) { log('콜백 호출 생성 실패(서버 미연결). 상단의 "재연결" 또는 "재발급"을 눌러주세요.', 'bad'); return; }
            activeCall = call;
            log(`게스트로 콜백 발신 → ${pendingPeerToCall}`, 'ok');
            wireCallEvents(call);
            pendingPeerToCall = null;
          } catch (e) {
            log('콜백 발신 실패: ' + e, 'bad');
          }
        } else {
          log('콜백 대기 중: 먼저 "오디오 공유 시작"을 눌러주세요.', 'bad');
        }
      }
    }

    function wireCallEvents(call){
      if (!call || typeof call.on !== 'function') { log('콜 객체가 없어 이벤트 바인딩을 건너뜁니다.', 'bad'); return; }
      call.on('stream', (remoteStream) => {
        log('원격 스트림 수신', 'ok');
        const audio = $('#remoteAudio');
        audio.srcObject = remoteStream;
        // iOS 등 자동재생 제한 보완
        audio.play().catch(()=>{
          log('자동재생이 차단되었습니다. "사운드 활성화"를 눌러주세요.', 'bad');
        });
      });
      call.on('close', () => log('콜 종료됨'));
      call.on('error', (e) => log('콜 에러: ' + e, 'bad'));
    }

    // ---------- Capture (Host) ----------
    async function startSystemAudioCapture(){
      // 1차 시도: audio-only (일부 브라우저에서 가능)
      try {
        log('시스템 오디오 캡처 시도: audio-only…');
        const s1 = await navigator.mediaDevices.getDisplayMedia({ video:false, audio:true });
        systemStream = s1;
        $('#captureState').textContent = '공유 중';
        $('#captureState').style.background = '#052e2b';
        $('#captureState').style.borderColor = '#10b981';
        log('시스템 오디오 캡처 성공 (audio-only)', 'ok');
        tryCallBackIfReady();
        return;
      } catch (e1) {
        log('audio-only 캡처 실패, video 포함 재시도: ' + e1, 'bad');
      }
      // 2차 시도: video:true 포함. 비디오 트랙은 무시.
      try {
        const constraints = { video:true, audio:true };
        log('시스템 오디오 캡처 시도: video+audio…');
        const s2 = await navigator.mediaDevices.getDisplayMedia(constraints);
        systemStream = s2;
        $('#captureState').textContent = '공유 중 (video 포함)';
        $('#captureState').style.background = '#052e2b';
        $('#captureState').style.borderColor = '#10b981';
        log('시스템 오디오 캡처 성공 (video+audio)', 'ok');
        tryCallBackIfReady();
      } catch (e2) {
        log('시스템 오디오 캡처 실패: ' + e2, 'bad');
      }
    }

    function stopSystemAudioCapture(){
      if (!systemStream) return;
      systemStream.getTracks().forEach(t => t.stop());
      systemStream = null;
      $('#captureState').textContent = '미시작';
      $('#captureState').style.background = '#0b1020';
      $('#captureState').style.borderColor = 'rgba(148,163,184,.25)';
      log('시스템 오디오 캡처 중지', 'ok');
    }

    // ---------- readiness helpers ----------
    function isPeerUsable(){
      return !!(peer && peer.open && !peer.destroyed);
    }

    function ensurePeerOpen(timeoutMs = 4000){
      return new Promise((resolve) => {
        if (isPeerUsable()) return resolve(true);
        // 연결 끊김이면 재연결 시도
        if (peer && peer.disconnected && !peer.destroyed) {
          try { peer.reconnect(); log('서버 재연결 시도…'); } catch(e){ log('reconnect() 실패: ' + e, 'bad'); }
        }
        // open 이벤트 대기
        let done = false;
        const onOpen = () => { if (!done){ done = true; cleanup(); resolve(true); } };
        const onError = () => { if (!done){ done = true; cleanup(); resolve(false); } };
        const cleanup = () => {
          try { peer.off('open', onOpen); } catch(e){}
          try { peer.off('error', onError); } catch(e){}
        };
        try { peer.on('open', onOpen); peer.on('error', onError); } catch(e){ resolve(false); }
        setTimeout(() => { if (!done){ done = true; cleanup(); resolve(isPeerUsable()); } }, timeoutMs);
      });
    }

    // ---------- Call controls ----------
    async function placeCall(){
      const remoteId = $('#remoteId').value.trim();
      if (!remoteId) { log('상대 Peer ID를 입력하세요', 'bad'); return; }

      const ready = await ensurePeerOpen();
      if (!ready) { log('서버 연결이 준비되지 않았습니다. 상단의 "재연결" 또는 "재발급"을 눌러주세요.', 'bad'); return; }

      const role = $('#role').value;
      if (role === 'host') {
        if (!systemStream) { log('Host는 먼저 "오디오 공유 시작"으로 캡처를 시작하세요.', 'bad'); return; }
        try {
          try { activeCall?.close(); } catch(e){}
          const call = peer.call(remoteId, systemStream);
          if (!call || typeof call.on !== 'function') { log('호출 생성 실패 (peer.call이 유효한 객체를 반환하지 않음)', 'bad'); return; }
          activeCall = call;
          log(`발신 중 → ${remoteId} (audio 송신)`, 'ok');
          wireCallEvents(activeCall);
        } catch (e) {
          log('호출 실패: ' + e, 'bad');
        }
      } else {
        // Guest: 데이터 연결로 콜백 요청
        try {
          if (!peer || peer.destroyed) { log('Peer 인스턴스가 유효하지 않습니다. "재발급"을 눌러 새로 만드세요.', 'bad'); return; }
          if (activeConn && activeConn.open) { try { activeConn.close(); } catch(e){} }
          const conn = peer.connect(remoteId, { reliable: true });
          if (!conn || typeof conn.on !== 'function') { log('데이터 연결 생성 실패(서버 미연결 또는 피어 ID 문제).', 'bad'); return; }
          activeConn = conn;
          log(`호스트에 콜백 요청 시도 → ${remoteId}`);
          conn.on('open', () => {
            log('데이터 채널 open (콜백 요청 전송)', 'ok');
            try { conn.send({ type: 'ring', from: myId }); } catch(e){ log('콜백 요청 전송 실패: '+e, 'bad'); }
          });
          conn.on('error', e => log('데이터 연결 에러: ' + e, 'bad'));
          conn.on('close', () => log('데이터 연결 종료'));
        } catch (e) {
          log('콜백 요청 실패: ' + e, 'bad');
        }
      }
    }

    function hangup(){
      try { activeCall?.close(); } catch(e){}
      activeCall = null;
      log('통화 종료 요청');
    }

    // ---------- UI wiring ----------
    window.addEventListener('DOMContentLoaded', async () => {
      await createPeer();

      $('#copyId').addEventListener('click', async () => {
        try { await navigator.clipboard.writeText($('#myId').value); log('내 ID 복사됨', 'ok'); } catch(e){ log('클립보드 복사 실패: '+e, 'bad'); }
      });
      $('#refreshPeer').addEventListener('click', createPeer);
      $('#reconnectPeer').addEventListener('click', async () => {
        if (!peer) return createPeer();
        if (peer.disconnected && !peer.destroyed) {
          try { peer.reconnect(); log('서버 재연결 시도…'); } catch(e){ log('reconnect() 실패: ' + e, 'bad'); }
        } else if (!peer.open) {
          await createPeer();
        } else {
          log('이미 서버와 연결됨');
        }
      });

      $('#role').addEventListener('change', (e) => {
        const role = e.target.value;
        $('#hostControls').classList.toggle('hidden', role !== 'host');
        $('#guestControls').classList.toggle('hidden', role !== 'guest');
        log(`역할 전환: ${role}`);
      });

      $('#startShare').addEventListener('click', startSystemAudioCapture);
      $('#stopShare').addEventListener('click', stopSystemAudioCapture);

      $('#callBtn').addEventListener('click', placeCall);
      $('#hangupBtn').addEventListener('click', hangup);

      $('#enableSound').addEventListener('click', () => {
        const a = $('#remoteAudio');
        a.muted = false;
        a.play().then(()=> log('사운드 활성화됨', 'ok')).catch(e=> log('재생 실패: '+e, 'bad'));
      });
    });
  </script>
</body>
</html>
